---
icon: edit
date: 2022-11-10
category:
  - Vue
tag:
  - Vue Router3
  - 导航守卫
star: true
---

# Vue Router3 导航守卫种类

## 概述

在实例应用中，诸如限制用户在登录后才能访问的需求十分常见，因此，对于项目中的**导航**（路由链接），可使用**导航守卫**控制每个路由的**访问权限**

**Vue Router** 提供的导航守卫，主要通过**跳转**或**取消**的方式守卫导航，要实现导航守卫功能，需使用路由实例 `router` 提供的实例方法

下面将以 [Vue Router3](https://v3.router.vuejs.org/zh/) 的导航守卫为例，详细介绍导航守卫的**种类**

<!-- more -->

## 导航守卫本质

一个 Vue 实例从**创建、运行、销毁**的每一个时期，都对应各自的生命周期函数，也称为钩子函数，随组件的生命周期**自动按序**执行
:::tip 组件生命周期
若你不了解组件生命周期，可参考这篇文章：[详解 Vue2 组件生命周期](/技术博文/Vue/详解Vue2组件生命周期.html)
:::

相应地，一个完整的导航解析流程，可近似看作是一个导航的生命周期，在每个流程中都设有相应的钩子函数，因此本质上，**每种守卫都是一种生命周期函数**

## 导航守卫分类

按照导航守卫的使用时机与场景，可分为 **4** 类导航守卫与 **1** 个钩子函数

### 一、全局前置守卫（beforeEach）

当一个导航触发时，全局前置守卫按照所有守卫的**创建顺序**被调用

守卫是**异步解析执行**，此时导航在所有守卫 resolve 完之前一直处于**等待**中

#### 调用语法

在已创建好的路由模块 `index.js` 中，在创建 `router` 实例后，调用其提供的实例方法 `beforeEach()`

```js
// 路由模块
const router = new VueRouter({...})
router.beforeEach((to, form, next) => {})
```

`router.beforeEach()` 为**异步任务**，接收一个**异步回调函数**，项目全局下只要有导航被触发，**必然**会触发该异步回调函数，它可接收以下三个形参（**顺序不可乱**）：

1.  **to**
    - 在导航被触发后，接收所访问路径（即将进入）对应的**路由信息对象**
    - 等同于**将要访问**的页面路径对应的 `this.$route`
2.  **from**
    - 在导航被触发后，接收触发前页面路径（当前离开）所对应**的路由信息对象**
    - 等同于**将要离开**的页面路径对应的 `this.$route`
3.  **next**

    - 该参数为一个**函数**，在守卫中**必须**要调用该方法来 resolve 每个守卫，每个守卫的执行效果完全依赖 `next` 方法的调用参数，守卫中若省略该方法，则页面所有导航都**失去**导航功能
    - `next` 函数在完整的导航解析流程的每一步中，充当允许进入下一步的角色，参见[导航解析流程]()
    - 依据不同的调用参数，导航守卫可实现 4 种执行效果：

      - （1）直接调用，无需传参：`next()`  
        表示**直接通过**当前导航守卫，可进入下一个导航钩子函数，若全部钩子执行完毕，则该导航的状态就是 `confirmed`（导航成功）
      - （2）传入布尔值 false：`next(false)`  
        表示**中断**当前的导航，**不允许跳转**至任何页面，用户手动修改页面 URL 或点击浏览器历史后退按钮，页面 URL 会被重置到形参 `from` 路由对应的地址
      - （3）传入参数：`next(参数)`  
        表示**中断**当前导航的同时，**开启新的导航**跳转到参数指定的地址：

        > 1. 传入**字符串**：  
        >    表示匹配路径的字符串，可携带查询参数，由 `？` 开始作引导
        > 2. 传入**对象**：
        >    - 可传入**描述地址的对象**，如 `{ path: '/home' }`
        >    - 可传入**命名路由对象**，如 `{ name: 'user', params: { userId: '123' }}`
        >    - 对象中允许设置诸如 `replace: true` 之类的选项以及任何用在 `router-link` 的 `to` 属性值，或 `router.push()` 方法的第一个参数（两者使用基本一致）

      - （4）传入一个 `Error` 实例：`next(error)`  
        表示当前导航会被**终止**且该错误会被传递给 `router.onErroe()` 注册过的回调函数

:::info 守卫触发时机

- 页面初始渲染时
- 全局任何**声明式**或**编程式**导航被触发后，在路由信息对象中进行路径匹配，解析渲染映射组件之前，执行守卫逻辑
  :::

#### 示例

```js
// 要求必须有访问权限才可访问后台系统主页，否则跳转至登录页
router.beforeEach((to, from, next) => {
  // 获取localStorage中的token值
  const token = localStorage.getItem('token')
  if (to.path !== '/login' && !token) next('login')
  else next()
})
```

### 二、全局解析守卫（beforeResolve ）

与全局前置守卫类似，由全局**任意导航**触发，不同的是，全局解析守卫的触发时机是导航解析完毕（确认）**之前**，正如其使用到的方法名 beforeResolve

`router.beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置

#### 调用语法

在已创建好的路由模块 `index.js` 中，在创建 `router` 实例后，调用其提供的实例方法 `beforeResolve()`

```js
// 路由模块
const router = new VueRouter({...})
router.beforeResolve((to, form, next) => {})
```

`router.beforeResolve()` 同样接收一个**异步回调函数**，形参的使用与[全局前置守卫](#调用语法)中的一致，此处不再重复

在路由模块中：router.beforeResolve()，该方法同样接收一个回调函数，对应的形参与全局前置守卫一致

### 三、全局后置钩子（afterEach）

### 四、路由独享守卫（beforeEnter）

### 五、组件内守卫

除了在全局以及路由配置中设置守卫，还可在组件切换渲染时设置导航守卫
根据进入组件、复用组件、离开组件可分为 3 类导航守卫

:::tip 路由组件
组件内守卫要想生效，前提是该组件是通过 Vue Router 的路由进行展示的
:::

## 总结

|              | 全局类守卫                                 | 路由独享守卫     | 组件内守卫                                                                                   |
| ------------ | ------------------------------------------ | ---------------- | -------------------------------------------------------------------------------------------- |
| 具体守卫     | beforeEach<br/>beforeResolve<br/>afterEach | beforeEnter      | beforeRouteEnter<br/>beforeRouteUpdate<br/>beforeRouteLeave                                  |
| 定义位置     | 路由模块                                   | 路由配置         | 组件默认导入对象                                                                             |
| 触发对象     | 全局所有导航                               | 导航至该路由配置 | 导航至组件所属路由（进入、复用、离开）                                                       |
| 访问组件实例 | 无法访问                                   | 无法访问         | 除了 beforeRouteEnter 需通过 next 回调（唯一支持守卫）获取组件实例，其余可直接通过 this 访问 |
